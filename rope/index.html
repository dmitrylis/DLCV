<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Drawing on Canvas</title>

  <script src="./victor.js"></script>

  <script>
    class MyVertex {
      constructor(pos, locked) {
        this.pos = pos
        this.prevPos = pos.clone()
        this.locked = locked
      }
    }

    class MyEdge {
      constructor(vertexA, vertexB) {
        this.vertexA = vertexA
        this.vertexB = vertexB

        var posA2 = vertexA.pos.clone()
        var posB2 = vertexB.pos.clone()
        this.length = posA2.subtract(posB2).length()
      }
    }

    function drawLine(context, x1, y1, x2, y2, size) {
      context.beginPath()

      context.moveTo(x1, y1)
      context.lineTo(x2, y2)

      context.lineWidth = size
      context.lineCap = "round"
      context.stroke()
    }

    function drawPoint(context, x, y, color, size) {
      context.beginPath()
      context.fillStyle = color
      context.arc(x, y, size, 0 * Math.PI, 2 * Math.PI)
      context.fill()
    }

    window.onload = function() {
      const gravity = new Victor(0.0, 2.8)
      const numOfIterations = 100
      const epsilon = 20

      const vertexes = []
      const edges = []

      function generateGrid(w, h) {
        for (let i = 0; i < h; ++i) {
          for (let j = 0; j < w; ++j) {
            const isLocked = (w === 1 || h === 1) ? (i === 0) && (j === 0) : (i === 0) && (j % 2 === 0)
            vertexes.push(new MyVertex(new Victor(100 + j * 50, 100 + i * 50), isLocked))

            if (j > 0) {
                edges.push(new MyEdge(vertexes[vertexes.length - 2], vertexes[vertexes.length - 1]))
            }

            if (i > 0) {
                edges.push(new MyEdge(vertexes[(i - 1) * w + j], vertexes[i * w + j]))
            }
          }
        }
      }

      let time = 0.0

      function simulate() {
        if (vertexes.length === 0 || edges.length === 0) {
            return
        }

        for (const vertex of vertexes) {
            if (!vertex.locked) {
                const posBefore = vertex.pos.clone()

                vertex.pos.add(vertex.pos.clone().subtract(vertex.prevPos))
                vertex.pos.add(gravity.clone().multiply(new Victor(time, time)))

                vertex.prevPos = posBefore
            }
        }

        for (let j = 0; j < numOfIterations; ++j) {
            for (const edge of edges) {

                const edgeCenter = edge.vertexA.pos.clone().add(edge.vertexB.pos).multiply(new Victor(0.5, 0.5))
                const edgeDir = edge.vertexA.pos.clone().subtract(edge.vertexB.pos).normalize()

                if (!edge.vertexA.locked) {
                    edge.vertexA.pos = edgeCenter.clone().add(edgeDir.clone().multiply(new Victor(edge.length * 0.5, edge.length * 0.5)))
                }

                if (!edge.vertexB.locked) {
                    edge.vertexB.pos = edgeCenter.clone().subtract(edgeDir.clone().multiply(new Victor(edge.length * 0.5, edge.length * 0.5)))
                }
            }
        }
    }

    const canvas = document.getElementById("myCanvas")
    const context = canvas.getContext("2d")

    canvas.width = window.innerWidth
    canvas.height = window.innerHeight

    var currentVertex = null
    var wasLocked = false

    generateGrid(9, 6)

    canvas.onmousedown = function(e) {
      if (e.button === 0) {
          if (vertexes.length === 0) {
              return
          }

          let minLength = Number.MAX_SAFE_INTEGER
          const mousePos = new Victor(e.clientX, e.clientY)

          for (const vertex of vertexes) {
              const currentLength = mousePos.clone().subtract(vertex.pos).length()
              if (currentLength < minLength) {
                  minLength = currentLength

                  if (minLength < epsilon) {
                      currentVertex = vertex
                  }
              }
          }

          if (currentVertex) {
              wasLocked = currentVertex.locked
              currentVertex.locked = true
          }
      }
    }

    canvas.onmouseup = function(e) {
      if (e.button === 0) {
          if (currentVertex) {
              currentVertex.locked = wasLocked
              currentVertex = null
          }
      }
    }

    canvas.onmousemove = function(e) {
      if (currentVertex) {
          currentVertex.pos = new Victor(e.clientX, e.clientY)
      }
    }

    canvas.ontouchstart = function(e) {
      if (vertexes.length === 0) {
          return
      }

      let minLength = Number.MAX_SAFE_INTEGER
      const mousePos = new Victor(e.touches[0].clientX, e.touches[0].clientY)

      for (const vertex of vertexes) {
          const currentLength = mousePos.clone().subtract(vertex.pos).length()
          if (currentLength < minLength) {
              minLength = currentLength

              if (minLength < epsilon) {
                  currentVertex = vertex
              }
          }
      }

      if (currentVertex) {
          wasLocked = currentVertex.locked
          currentVertex.locked = true
      }
    }

    canvas.ontouchmove = function(e) {
      e.preventDefault()

      if (currentVertex) {
          currentVertex.pos = new Victor(e.touches[0].clientX, e.touches[0].clientY)
      }
    }

    canvas.ontouchend = function(e) {
        if (currentVertex) {
            currentVertex.locked = wasLocked
            currentVertex = null
        }
    }

    canvas.ontouchcancel = function(e) {
        if (currentVertex) {
            currentVertex.locked = wasLocked
            currentVertex = null
        }
    }

    setInterval(function() {
      time += 0.01

      simulate()

      context.clearRect(0, 0, canvas.width, canvas.height)

      for (const edge of edges) {
        drawLine(context, edge.vertexA.pos.x, edge.vertexA.pos.y, edge.vertexB.pos.x, edge.vertexB.pos.y, 10)
      }

      for (const vertex of vertexes) {
        const col = (currentVertex === vertex) ? "#ffc700" : (vertex.locked ? "#ff0000" : "#b4b4b4")
        drawPoint(context, vertex.pos.x, vertex.pos.y, col, 3)
      }
    }, 33);
    };
  </script>
</head>

<body>
  <canvas id="myCanvas" width="1000" height="1000"></canvas>
</body>

</html>
